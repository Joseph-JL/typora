# 三、行为型设计模式

## 1 职责链模式
> Chain of Responsibility Pattern
> * ==使多个对象都有机会处理请求==，从而避免请求的发送者和接受者之间的耦合关系。
> * 将可能处理请求的多个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理了为止。
> 即请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。
> * 提交请求的对象 也不明确哪一个对象会处理它。
> 根据运行时刻，任意候选者都可以响应响应的请求，候选者数目任意，可以在运行时刻决定哪些候选者参与到链中。

**优点**
1. 解耦了 请求发送者和 N个接受者之间的复杂关系，
由于不知道链中有多少个结点可以处理你发送的请求，只需要将请求发送给第一个结点。
2. 利用了职责链，链中结点对象可以灵活拆分重组，
增加或者删除一个结点，或者改变结点在链中的位置 都是很简单的事情
3. 可以手动指定起始结点，请求不一定要从第一个结点开始传递

**缺点：**
1. 多了一些节点对象，可能在某一次请求过程中，大部分结点并没有起到实质性的作用，他们的作用仅仅是让请求传下去

2. 如果一个结点出错，就会导致整条连断开。

## 2 命令模式
> * ==将一个请求封装成对象，==
> 从而让你 ==使用不同的请求== -> 
> 把客户端参数化，对请求排队或者记录日志，可以提供命令撤销和恢复功能。
> 
> * 命令模式的核心——引入了 ”命令类“，
> 通过命令类 来降低发送者和接受者的耦合度
> 请求发送者 只需制定一个命令对象，再通过命令对象来调用请求接收者的处理办法。

![image-20210406190252092](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406190252092.png)

命令模式
> 可以将 “请求发送者”和“请求接收者”完全解耦，
> 发送者与接受者之间没有直接引用关系，
> 发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。

**角色**
> Receiver——命令接收者角色，命令传递到这里==执行==对应的操作
> Command——命令角色，需要执行的==命令在这里声明==
> Invoker——调用者角色，接收到命令+执行命令，命令的发动者和调用者

**实例**

invoker引用command，invoker的call方法中调用了command的executer方法
command引用receiver，command的executer方法中调用了receiver的action方法

1. 抽象Command类
```java
	public abstract class Command{
		public abstract void execute();
	}
```
2. 调用者invoker类
```java
	public class Invoker{
		public Command command;
		//构造注入
		public Invoker(Command command){
			this.command=command;
		}
		//设值注入
		public void setcommand(Command command){
			this.command=command;
		}
		
		//【关键】业务方法，用于调用命令类的execute()方法
		public void call(){
			command.execute();
		}
	}
```
3. 具体ConcreteCommand类，设置对应的接收者
```java
public class ConcreteCommand extends Command{
	//维持一个对请求接收者对象的引用
	private Receiver receiver;
	
	public ConcreteCommand(Receiver receiver){
		super();
		this.receiver=receiver;
	}
	
	public void execute(){
		//【关键】调用请求接收者的业务处理办法action()
		receiver.action();
	}
}
```
4. 抽象接收者
```java
public abstract Receiver{
	public abstract void action();
}
```
第一个具体接收者
```java
public class ConcreteReceiver1 extends Receiver{
	@override
	public void action(){
		system.out.println("ConcreteReceiver1 receives the command");
	}	
}
```
第二个具体接收者
```java
public class ConcreteReceiver2 extends Receiver{
	@override
	public void action(){
		system.out.println("ConcreteReceiver2 receives the command");
	}	
}
```
5. 测试类，创建了2个接受者，分别发送指令
```java
public class Client{
	public static void main(String[] args){
		//接收者1
		Receiver receiver=new ConcreteReceiver1();
		Command command1=new ConcreteCommand(receiver1);
		
		Invoker invoker=new Invoker();//初始化Invoker
		invoker.setCommand(command1);
		invoker.call();
		
		//接收者2
		Receiver reveiver=new ConcreteReceiver2();
		Command command2=new ConcreteCommand(receiver2);
		
		invoker.setCommand(command1);//重新设置invoker
		invoker.call();
		
	}
}
```
**小结**
> 1. 命令模式的本质——对请求进行封装，
> 一个请求对应于一个命令，将发出命令的责任 和执行命令的责任 分割开。
> 2. 每一个命令都是一个操作：
> 请求的一方 发出请求要求执行一个操作，
> 接收的一方 收到请求并执行相应的操作。
> 
> 3. 命令模式允许请求的一方和接收的一方独立开来，
> 使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及怎样执行。
> 4. 命令模式的关键——引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。

**优点**
* 类间解耦
invoker和receiver没有任何依赖关系，
invoker实现功能时只调用command抽象类的execute方法就可以，
不需要知道到底是哪个接收者在执行。
* 可扩展性
Command子类很容易扩展，而invoker和client不产生严重的代码耦合

**缺点**
* 造成了类膨胀，如果有多个子命令则需对应多个Command子类，比较繁琐。

## 3 解释器模式
** 定义**
给定一种语言+定义它的文法的一种==表示==+
定义一个解释器，==该解释器使用该表示== 来解释语言中的句子

**结构**
![image-20210406195623145](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406195623145.png)

> 1. AbstractExpression:抽象解释器：
> 声明一个抽象的解释操作，这个接口为抽象语法树所有的节点所共享。
> 2. TerminalExpression：终结解释器
> 实现与文法中的 "终结符" 相关的解释操作，一个句子中的每个终结符 需要该类的一个实例。
> 3. NonterminalExpression:非终结解释器
> 对==文法中的规则==的解释操作
> 
> 4. Context:环境角色——包含解释器之外的一些全局信息。
> 5. Client:客户端——构建 表示该语法定义的语言中 一个特定的句子 的抽象语法树，并调用解释操作。

**优点**
> 1. 解释器是一个简单的语法分析工具，可扩展性：
> 2. 修改语法规则只需要修改相应的非终结符就可以了
> 若扩展语法，只需要增加非终结符类就可以了。

**缺点**
> 1. 会引起类的膨胀，每个语法偶需要产生一个非终结符表达式，
> 语法规则比较复杂时，就可能产生大量的类文件。

## 4 迭代器模式
> 提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，
> 其别名为游标（Cursor）。

![image-20210406201225352](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406201225352.png)

**举例**
迭代器帮助请求方获取数据，避免直接操作数据聚合类，使得数据聚合类专注存储数据。
具体应用有分页等功能，分页功能的迭代器，将专门负责操作分页数据，==将操作逻辑和数据源分离。==

**优点**
> * 它支持以不同的方式遍历一个聚合对象，> 在同一个聚合对象上可以定义多种遍历方式。
> 在迭代器模式中，只需要用 一个不同的迭代器 来替换原有迭代器 即可改变遍历算法，
> 也可以自己定义迭代器的子类 以支持新的遍历模式。
> * 简化了聚合类。
> 由于引入了迭代器，在原有的聚合对象中 不需要在自行提供数据遍历的方法
> * 引入了抽象层，增加新的聚合类和迭代器类都很方便，无需修改原有代码，满足“开闭原则”要求

**缺点**
> * 迭代器模式将存储数据和遍历数据的职责分离，
> 增加新的聚合类 需要对应增加 新的迭代器类
> * 抽象迭代器的设计难度较大，需要充分考虑到系统将来的可扩展

## 5 中介者模式
> 用一个中介对象（中介者）来==封装一系列的对象交互==，
> 中介者使得各对象 不需要显式的调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。
> 又称 “调停者模式”

![image-20210406202907564](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406202907564.png)

**举例**
中介者模式将一个网状的系统结构->变成一个 ==以中介者对象为中心的星型结构==，
使得中介者对象与其他对象的一对多关系 取代原有对象之间的多对多关系。
所有成员通过中介者交互，方便扩展新成员。

例如下面的例子，新增聊天室成员只需要新建一个成员实例，然后在聊天室中介者那注册就可以加入聊天室。

**优点**
> * 简化了对象之间的交互，
> 利用中介者和同事的一对多交互 代替了 原来同事之间的多对多交互。
> 一对多关系更容易理解、维护和拓展，
> 将原本难以理解的网状结构 转换成相对简单的星型结构。
> * 可将各同事对象解耦。
> 中介者有利于各同事之间的松耦合，
> 可以独立的改变和复用每一个同事和中介者，
> 增加一个新的中介者和新的同事类都比较方便，更好的符合“开闭原则”
> * 可以减少子类的生成
> 中介者将原本分布于多个对象间的行为集中在一起，
> 改变这些行为只需生成新的中介者子类即可，
> 这使得各个同事类可以被复用，无需对同事类进行扩展

**缺点**
> * 在具体中介者中 包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

## 6 备忘录模式
> 在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，
> 这样可以在以后将对象 恢复到原先保存的状态。
> 别名Token

**举例**
* 备忘录模式——提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，
当新的状态无效或者存在问题时，可以使用暂时存储起来的 备忘录将状态复原；
很多软件都提供了撤销操作——使用了备忘录模式。

**优点**
* 提供了一种状态恢复的实现机制，
使得用户可以方便地回到一个特定的历史步骤，
当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。
* 实现了对信息的封装，
一个备忘录对象是一个原发器对象状态的表示，不会被其他代码所改动。
备忘录保存了原发器的状态，采用列表，堆栈等集合来存储备忘录对象，可以实现多次撤销操作。

**缺点**
* 资源消耗过大，如果需要保存的原发器的成员变量太多，就不可避免需要占用大量的存储空间，
每保存一次对象的状态 都需要消耗一定的系统资源。

## 7 观察者模式
> 定义对象之间的一种 一对多依赖关系，
> 使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新，
> 别名 包括：
> “发布-订阅”模式（Publish/Subscribe）、
> “模型-视图“模式（Model/View）、
> “源-监听器”模式（Source/Listener）、
> “从属者”模式（Dependents）

![image-20210406210917887](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406210917887.png)

**举例**
使用频率最高的设计模式之一——==用于建立一种对象与对象之间的依赖关系，==
一个对象发生改变时自动通知其它对象，其他对象将相应做出反应。

**优点**
* 可以实现 表示层和数据逻辑层 的分离，
定义了稳定的消息更新传递机制，并抽象了更新接口，
使得可以有各种各样不同的表示层 充当具体观察者角色。
* 在观察目标和观察者之间建立了一个抽象的耦合。
观察目标只需要维持一个抽象观察者的集合，无需了解其具体观察者。
由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
* 观察者模式支持广播通信，
观察目标会像所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
* 观察者模式满则 “开闭原则”的要求，
增加新的具体观察者无须修改原有系统代码，
在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

**缺点**
* 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。
* 如果在观察者和观察目标之间存在循环依赖，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。
* 没有相应的机制 让观察者知道所观察的目标对象是怎么发生的，而仅仅只是知道观察目标发生了变化。

## 8 状态模式
> 允许一个对象 在其内部==状态改变时 改变他的行为==，对象看起来似乎修改了它的类。
> 别名：状态对象（Objects forStates）

![image-20210406212711573](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406212711573.png)

**举例**
==状态模式——用于解决 “复杂对象的状态转换 以及不同状态下行为 ” 的封装问题。==
当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以==对象在不同状态下具有不同行为==时 可以使用状态模式。
状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。

简单的例子：
设计一个银行账户系统——==根据存钱余额来自动设置账户的状态==，
==银行账户在不同的状态下，进行存钱、取钱、和借钱的行为==。
在不同状态下，这些行为得到的回复也不一样，比如说没有余额时无法取钱，只能存钱和借钱。

**优点**
1. 封装了状态的转换规则，
在状态模式中可以将 “状态的转换代码” 封装在环境类或者具体状态类中，
可以对 状态转换代码进行集中管理，而不是分散在一个个业务方法中。
2. 将==所有 与某个状态有关的行为 放到一个类==中，
只需要注入一个不同的状态对象 即可使环境对象拥有不同的行为。
3. 允许状态转换逻辑与状态对象 合成一体，而不是提供一个巨大的条件语句块，
状态模式可以让我们避免使用 庞大的条件语句 来==将业务方法和状态转换代码== 交织在一起
4. 可以让多个环境变量 共享一个状态对象，从而减少系统中对象的个数。

**缺点**
* 状态模式的使用 必然会增加系统中 类和对象的个数，导致系统运行开销增大。
* 状态模式的结构和实现都较为复杂
* 对“开闭原则”支持不友好，
增加新的状态类 需要修改那些负责状态转换的源代码，否则无法转换到新增状态。
而修改某个状态类的行为也需修改对应类的源代码。

## 9 策略模式
> 定义一系列算法类，将每个算法封装起来，并且它们可以相互替换，
> 策略模式==让算法独立于 使用它的客户而变化，==
> 也称：政策模式（Policy）

![image-20210406215839496](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406215839496.png)

**举例**
> * 使用策略模式时，我们可以定义一些策略类，每一个策略类中封装一种具体的算法。
> * 每一个封装算法的类我们都可以称之为一种策略，
> 根据传入不同的策略类，使得环境类执行不同策略类中的算法。

> 例如：商城中的会员卡机制。
> 购买同一件商品是，持有不同等级的会员卡，能得到不同力度的折扣。最终需要支付的金额也会有所不同。

**优点**
> 1. 对“开闭原则”完美支持，
> 用户可以在不修改原有系统的基础上 选择算法或行为，也可以灵活地增加新的算法或行为。
> 2. 策略模式提供了管理 相关的算法族 的办法，
> 策略类的等级结构 定义了一个算法或行为族，
> 恰当使用继承 可以把公共的代码移到抽象策略类中，从而避免重复的代码。
> 3. 提供了一种可以替换继承关系 的办法，
> 如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个字类提供一种不同的算法。
> 4. 可以避免多重条件选择语句，
> 多重条件选择语句不易维护，它把 采取哪一种“算法（行为）”与 “算法（行为）本身”的实现逻辑 混合在了一起，
> 将他们全部“硬编码”（hard cording）在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要落后。
> 5. 提供了一种“算法的复用机制”，
> 由于将算法单独提取出来 封装在策略类中，因此不同的环境类可以方便地复用这些策略类。

**缺点**
> 1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
> 即 策略模式只适用于client知道所有的算法（行为）的状态。
> 2. 将造成系统产生很多 具体策略类，任何细小的变化都将导致系统 增加一个新的具体策略类。
> 3. 无法同时在client使用多个策略类。
> client每次只能使用一个策略类，
> 不支持使用一个策略类完成部分功能后，再使用另一个策略类 来完成剩余功能的情况。

## 10 模板方法模式
> ==定义了一个操作中算法的框架，而将一些步骤延迟到了子类中。==
> 使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤。

![image-20210406221931747](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406221931747.png)

**举例**
模板方法模式具体应用分为三类：
> * 抽象方法：一个抽象方法有抽象类声明、由其具体子类实现。
> * 具体方法：有一个抽象类或具体类声明，其子类可以直接继承或覆写
> * 钩子方法：
> ==由一个抽象类 或具体类声明实现，而其子类可能会加以扩展。==
> 通常在其父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，
> 也可以提供一个非空的默认实现。
> 通过==在子类中 实现的钩子方法 对父类方法进行约束，实现子类对父类行为的反向约束==

**优点**
> 1. 在父类中形式化地定义一个算法，而有它的子类来实现细节的处理，
> 在子类实现详细的处理算法时，并不会改变算法中步骤的执行次序。
> 2. 是一种代码复用的技术，
> 在类库设计中尤为重要，提取了类库中的公共行为，
> 将公共行为放在父类中，而通过其子类来实现不同的行为，
> 它鼓励我们恰当使用继承 来实现代码复用。
> 3. 可实现一种==反向控制结构==，
> 通过子类覆盖父类的钩子方法 来决定某一特定步骤是否需要执行。
> 4. 可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，
> 更换和增加新的子类很方便，符合单一职责原则和开闭原则。

**缺点**
> * 需要为每个基本方法的不同实现提供一个子类，
> 如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大。

## 11 访问者模式
**定义**
> 封装一些 作用于==某种数据结构的各元素==的操作，
> 它可以在不改变这个数据结构的前提下 ，定义作用于这些元素 的新的操作。

实例——“处方单” 这样的集合对象结构，
在该 对象结构中存储了 多个不同类型的 对象信息，
而且对 对象结构内同一元素的操作方式并不唯一，可能需要提供多种不同的处理方式。

**角色**
> 1. Visitor（抽象访问者）：
> 为对象结构中每一个具体元素类ConcreteElement声明了一个访问操作，
> 从这个操作的名称和参数类型 ，清楚的知道需要访问的具体元素的类型，
> 具体访问者需要实现这些操作方法，定义对这些元素的访问操作。
> 2. ConcreteVisitor（具体访问者）：
> 实现了抽象访问者声明的方法，每一个操作作用于 访问对象结构中 一种类型的元素。
> 3. Element（抽象元素）：
> 一般是一个抽象类或接口，
> 定义了一个Accept方法，该方法通常以一个抽象访问者作为参数。
> 4. ConcreteElement（具体元素）：
> 实现了了Accept方法，在Accept方法中调用访问者的访问方法，以便完成一个元素的操作。
> 5. ObjectStructure（对象结构）：
> 是元素的集合，用于存放元素对象，且提供遍历其内部元素的方法。

**结构**

![image-20210406235144636](https://cloudimg-joseph.oss-cn-beijing.aliyuncs.com/img/image-20210406235144636.png)

**实现**
汽车作为ObjectStructure,
里面包含引擎、车身等部分对象Element，
访问者角色对象为PrintVisitor，车接收该访问者让其访问车的各个组成对象 并打印信息；

1. Visitor
```java
//访问者接口，包含三个方法
public interface Visitor {
    void visit(Engine engine);
    void visit(Body body);
    void visit(Car car);
}
```
2. ConcreteVisitor
汽车打印访问者
```java
public class PrintCar implements Visitor {
    public void visit(Engine engine) {
        System.out.println("Visiting engine");
    }
    public void visit(Body body) {
        System.out.println("Visiting body");
    }
    public void visit(Car car) {
        System.out.println("Visiting car");
    }
}
```
汽车检修的访问者
```java
public class CheckCar implements Visitor {
    public void visit(Engine engine) {
        System.out.println("Check engine");
    }
    public void visit(Body body) {
        System.out.println("Check body");
    }
    public void visit(Car car) {
        System.out.println("Check car");
    }
}
```
3. Element
```java
public interface Visitable {
    void accept(Visitor visitor);
}
```
4. ConcreteElement
```java
public class Body implements Visitable {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```
```java
public class Engine implements Visitable {
    @Override    
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```
5. 对象结构
```java
public class Car{
	private List<Visitable> visit=new ArrayList<>();
	
	public void addVisit(Visitable visitable){
		visit.add(visitable);
	}
	
	public void show(Visitor visitor){
		for(Visitable visitable: visit){
			visitable.accept(visitor);
		}
	}
}
```
>  当前访问者模式 例子中 的对象结构，
>  这个列表是元素（Visitable）的集合，
>  这便是对象结构的通常表示，它一般会是一堆元素的集合，不过这个集合不一定是列表，也可能是树，链表等等任何数据结构，甚至是若干个数据结构，
>  其中的show方法，就是汽车类的精髓，它会枚举每一个元素，让访问者访问。

6. 测试类client
```java
public class Client{
	public static void main(String[] args){
		//对象集合
		Car car=new Car();
		car.addVisit(new Body());
		car.addVisist(new Engine());
		
		Visitor print=new PrintCar();
		car.show(print);
	}
}
```
> * 汽车中的元素很稳定，这些几乎不可能改变，而最容易改变的就是访问者这部分。
> * 最大优点——增加访问者非常容易，如果要增加一个访问者，只需要新增访问者实现Visitor接口，然后就可以直接调用 对象结构的说show方法去访问汽车了。

**适用于：**

> 访问者模式适用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作。
> 需要对一个 对象结构中的对象 进行很多不同的且不相关的操作，而需要避免在这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。

**优点**
> * 增加新的访问操作十分方便，符合开闭原则；
> * 将有关元素对象的访问行为 集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰，符合单一职责原则

**缺点**
> * 增加新的元素类很困难，需要在每一个访问者类中增加相应访问操作的代码，这违背了开闭原则；
> * 元素对象有时候必须暴露一些自己的内部状态和操作，否则无法供访问者访问，这破坏了元素的封装性。